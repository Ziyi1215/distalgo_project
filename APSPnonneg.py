# -*- generated by 1.0.12 -*-
import da
_config_object = {}
import sys
import random

class G():

    def __init__(self, weights, n):
        if (len(weights) == (n * n)):
            self.weights = weights
            self.np = n
        else:
            print('Input weights error')

    def neighbor(self, p):
        neighbor_ids = []
        neighbor_weights = self.weights[(p * self.np):((p + 1) * self.np)]
        for i in range(self.np):
            if (neighbor_weights[i] > 0):
                neighbor_ids.append(i)
        return neighbor_ids

    def distance(self, i, j):
        if (self.weights[((i * self.np) + j)] == (- 1)):
            return float('inf')
        else:
            return self.weights[((i * self.np) + j)]

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def setup(self, neighbor, **rest_384):
        super().setup(neighbor=neighbor, **rest_384)
        self._state.neighbor = neighbor
        self._state.neighbor = self._state.neighbor
        self._state.rounds = 0

    def run(self):
        while (self._state.rounds < 6):
            self.output(('round:' + str(self._state.rounds)))
            self._state.rounds += 1

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):
        n = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        weights = [0, (- 1), 3, 5, 0, 8, (- 1), (- 1), 0]
        graph = G(weights, n)
        ps = list(self.new(P, num=n))
        for (i, p) in enumerate(ps):
            print(graph.neighbor(i))
            self._setup({p}, [graph.neighbor(i)])
        self._start(ps)
