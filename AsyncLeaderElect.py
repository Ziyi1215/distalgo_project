# -*- generated by 1.0.12 -*-
import da
PatternExpr_219 = da.pat.TuplePattern([da.pat.ConstantPattern('probe'), da.pat.FreePattern('j'), da.pat.FreePattern('k'), da.pat.FreePattern('d')])
PatternExpr_230 = da.pat.FreePattern('source')
PatternExpr_324 = da.pat.TuplePattern([da.pat.ConstantPattern('reply'), da.pat.FreePattern('j'), da.pat.FreePattern('k')])
PatternExpr_333 = da.pat.FreePattern('source')
PatternExpr_432 = da.pat.TuplePattern([da.pat.ConstantPattern('leader'), da.pat.FreePattern('winid')])
_config_object = {}
import sys
import random

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_219, sources=[PatternExpr_230], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_218]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_324, sources=[PatternExpr_333], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_323]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_2', PatternExpr_432, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_431])])

    def setup(self, left, right, **rest_560):
        super().setup(left=left, right=right, **rest_560)
        self._state.left = left
        self._state.right = right
        self._state.leaderid = None
        self._state.asleep = True
        self._state.msg_left = []
        self._state.msg_right = []

    def run(self):
        self.initiate()
        super()._label('_st_label_453', block=False)
        _st_label_453 = 0
        while (_st_label_453 == 0):
            _st_label_453 += 1
            if (not (self._state.leaderid == None)):
                if (self._state.leaderid == self._id):
                    self.claim()
                    self.output(('Leader is ' + str(self._state.leaderid)))
                else:
                    self.output(('Leader is ' + str(self._state.leaderid)))
                _st_label_453 += 1
            else:
                super()._label('_st_label_453', block=True)
                _st_label_453 -= 1

    def initiate(self):
        if (self._state.asleep == True):
            self._state.asleep = False
            self.send(('probe', self._id, 0, 1), to={self._state.left, self._state.right})

    def claim(self):
        self.send(('leader', self._id), to=self._state.left)

    def _P_handler_218(self, j, k, d, source):
        if (j == self._id):
            self._state.leaderid = self._id
        if (source == self._state.left):
            if ((j > self._id) and (d < (2 ** k))):
                self.send(('probe', j, k, (d + 1)), to=self._state.right)
            elif ((j > self._id) and (d >= (2 ** k))):
                self.send(('reply', j, k), to=self._state.left)
        if (source == self._state.right):
            if ((j > self._id) and (d < (2 ** k))):
                self.send(('probe', j, k, (d + 1)), to=self._state.left)
            elif ((j > self._id) and (d >= (2 ** k))):
                self.send(('reply', j, k), to=self._state.right)
    _P_handler_218._labels = None
    _P_handler_218._notlabels = None

    def _P_handler_323(self, j, k, source):
        if (source == self._state.left):
            self._state.msg_left.append(('reply', j, k))
            if (not (j == self._id)):
                self.send(('reply', j, k), to=self._state.right)
            elif (('reply', j, k) in self._state.msg_left):
                self.send(('probe', self._id, (k + 1), 1), to={self._state.left, self._state.right})
        if (source == self._state.right):
            self._state.msg_right.append(('reply', j, k))
            if (not (j == self._id)):
                self.send(('reply', j, k), to=self._state.left)
            elif (('reply', j, k) in self._state.msg_right):
                self.send(('probe', self._id, (k + 1), 1), to={self._state.left, self._state.right})
    _P_handler_323._labels = None
    _P_handler_323._notlabels = None

    def _P_handler_431(self, winid):
        self._state.leaderid = winid
        self.send(('leader', winid), to=self._state.left)
    _P_handler_431._labels = None
    _P_handler_431._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):
        n = (int(sys.argv[1]) if (len(sys.argv) > 1) else 10)
        ps = list(self.new(P, num=n))
        random.shuffle(ps)
        for (i, p) in enumerate(ps):
            if (i == (len(ps) - 1)):
                self._setup({p}, (ps[(i - 1)], ps[0]))
            else:
                self._setup({p}, (ps[(i - 1)], ps[(i + 1)]))
        self._start(ps)
